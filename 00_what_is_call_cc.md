What is CALL/CC?
================

TAG: #LISP #Scheme

Scheme把续延当作第一级类型来对待。要理解call/cc如何使用，首先需要理解概念“续延”（Continuation）。任何的计算，都有一个续延，即那个在等待该计算的值的东西。

如式子`(+ 1 (+ 2 3))`中的计算`(+ 2 3)`的续延为`(+ 1 [])`，其中的“[]”指`(+ 2 3)`的值所要填进去的地方。若是写成调用栈的形式，就应该是这样：

```scheme
1. (+ 2 3)
0. (+ 1 [])
```

可以明显地看出，要完成第0层的计算，需要第1层的计算结果。而且，可以把第0层看作是一个类似于函数的东西，它“等待”一个值（接受一个参数）来完成计算。如此一来，我们便可以把续延以类似函数的形式保留下来，并能像函数一样调用（然而并不完全一样）。

观察下面的代码和计算结果：

```scheme
(define *k* '())

(define (f)
  (+ 33 (call/cc
	 (lambda (k)
	   (set! *k* k)
	   200))))

1. (f) => 233
2. (*k* 2200) => 2233
3. (+ 666 (*k* 1000)) => 1033
```

call/cc接受一个函数（这个函数只接受1个参数），call/cc立即调用这个函数，把当前的续延作为参数传给这个函数（R6RS把这个参数称为“Escape Procedure”）。这个函数的执行结果（200）被作为计算的结果传送给续延`(+ 33 [])`，所以计算1的计算结果是233。

其中，我保存了这个续延，所以可以在函数执行结束后继续使用这个续延。现在观察计算2，我们喂给续延一个值（2200），`(+ 33 [])`就计算出了2233。

计算3是比较有趣的地方，我们发现，计算`(*k* 1000)`的续延`(+ 666 [])`并没有执行。在Scheme中，调用一个续延时，计算就丢掉了自己的续延（可以理解成整个栈被替换了，确实可以这么实现）。所以我们得到值1033。

示例，当作“Return”来使用：

递归查找一个表中是否有某个符号，找到了就返回符号的“位置”。

```scheme
(define call/cc call-with-current-continuation)

(define (test lst id)
  (call/cc
    (lambda (ret)
      (define (check lst)
        (if (pair? lst)
          (if (eq? (car lst) id)
            (ret lst)
            (check (cdr lst)))
          (ret #f)))
      (check lst))))

(user)> (test '(a b c d e f) 'e)
(e f)
```
